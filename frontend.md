Front end development involves the interplay of performance and presentation, efficiency and style. Algorithms are important to the development of successful front ends as much as are design patterns. One can think of data structures as "algorithms frozen in time", at a high level. It is important to understand the concerns for the front end, as they may overlap with backend concerns, but they are, as it were, very different worlds. As Douglas Crockford points out, "the web is the most hostile development environment imaginable." We may think of the web browser as where maintainability, flexibility, evolvability and, of course the well-understood issue of cross-browser compatibility, these are central concerns for the front end developer, whereas the backend (APIs, scheduled jobs, etc.) may be more concerned with efficiency and correctness. Design patterns are the main focal point for addressing front end concerns, whereas algorithms are of the main interest of backend developers. These areas may overlap, as all developers should be familiar with the fundamentals of mathematics, computation and scientific practice, but it is of critical importance not to collapse the distinction of the properties (maintainability, flexibility, etc.) of the front end as merely a subordinate problem space to what would be backend properties (efficiency, etc.).In many areas there will be competing tools, frameworks, libraries, communities, etc. seeking to claim dominance for a set of use cases that would achieve the greatest engagement or benefit to end users. It is important to understand the efficient, formal, final and material properties that are pertinent to use cases, just as much as it is important to understand that they are rooted or grounded in real expectations of real users. Another critical distinction is that concerning the development, description, explanation and exploration of User Experience versus that of Developer Experience. A hot new tool or framework may improve Developer Experience, but the benefit to the user may be left wanting or unexplored. It is important to relate this distinction to the properties, efficient, formal, etc., of programs as they are developed, described, explained and explored in both the front end and backend. At the same time, the web browser is different from the native environment (iOS, Android, etc.) and the "front end" tools and languages (Swift, etc.) make less severe the kinds of overlapping interests and political whirlwind that takes place in web browser developments and web development. To certain extend, what takes place in the web front end is the most chaotic, whereas for native front end development proper, whether using Visual BASIC, Python or Swift, front end developers will experience less inter-organization conflict (Mozilla vs Microsoft vs Apple) and accelerated pace (e.g. the Browser Wars, lack of API capabilities, the need for progressive enhancement and graceful degradation). Outside looking in, one could argue that competition breeds innovation, but at times the Browser Wars have led to lack of problem solving and lack of API implementations of widely useful methods (e.g. see Proxy, Map, etc. on MDN and IE's lack of implementation). It's important to remember that while many speak of the oncoming singularity and the idea that technology rapidly changes and grows exponentially, whereas organizations change logarithmically, web pages load no faster than they did 10 years ago. The key question is what kind of problem is web page load speed: is it a matter of writing more efficient and correct code, as a backend developer might think, or is it otherwise, if not a problem to which there is no solution? To say the least, it doesn't look like the celebrated "radical growth" of technology is having an impact on web page loading speed, despite all the clever and inventive techniques that have been founded (prefetching, "critical pathing", lazy loading, minification, etc.). Of course, HTTP/3 shows minor speed improvements, based on what has been measured, but the underlying analytical model for understanding such a problem as perceived performance versus actual performance is, ultimately, whether or not it is difficult to integrate new front end methods and why it is some developers opt out or neglect them. For those more concerned with native environments and find the methodologies, tools and practices of web development to be unrelated or irrelevant to native, desktop, etc., there are still important questions to raise as to whether or not tools like React Native will, in the end, dominate in the future (depending on the use-case). So understanding what front end web development is doing right may be of interest to those working within the more restricted and closed off domains of front end development.